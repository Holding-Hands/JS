

# 十二. 异步编程之Promise/async/await



## 1. 图片加载之任务队列【宏任务】

```js
function loadImage(src,resolve,reject) {
    let image = new Image();
    image.src = src;
    image.onload = () => {
        resolve(image)
    };
    image.onerror = reject;
}

// 放入相对路径 要在html文件中运行哦，在控制台会报错找不到图片
loadImage('../image/star.jfif', 
          image => {
    console.log('图片加载完成');
    document.body.appendChild(image);
},
         (err) => {
    console.log('图片加载失败');
    throw new Error(err);
});

console.log('开始执行加载图片函数');


先把这个函数交给文件处理模块，等处理完，再放到任务队列中，主线程代码（从上到下执行完代码后），再去任务队列执行任务，不断地轮询
所以说先打印的【开始执行加载图片函数】在打印图片加载成功或失败

# 执行顺序在定时器前面
```



## 2. 定时器之任务队列【宏任务】

```js
js有专门处理定时器的模块，先执行主线程任务，如果遇到定时器任务，放入专门处理定时器任务的模块，等定时器时间到了，再放入任务队列中，等到主线程任务执行完之后，再去任务队列里面找轮询执行任务,在此期间如果定时器设置500ms之后执行，但是主线程执行代码时间超过500ms，这时候定时器任务会被放入到任务队列（把console.log(1)放到任务对立里），那么也要等主线程执行完毕之后，才会去轮询任务队列

let code = setInterval(() => console.log(1), 500);
console.time('z');
console.log('先执行主线程');
console.timeEnd('z');
// 执行顺序是先执行主线程代码

console.log('先执行主线程');在执行定时器任务


setInterval(() => console.log('我是后执行的'), 500);
setInterval(() => console.log('我是先执行的'), 100);

如果有多个定时器执行顺序也是，等谁先加载完，谁放入任务队列，如果时间相同那么就看执行的先后顺序

setInterval(() => console.log('我是先执行的'), 100);
setInterval(() => console.log('我是后执行的'), 100);
```



## 3. 文件依赖之任务队列

```js
我们先定义两个js文件内容

第一个js文件内容：
function show() {
    
}

第二个js文件内容：
function run() {
    show(); // 这个函数依赖第一个js文件里的函数
}

// 我们来定义一个加载js文件的函数
function loadScript (src, reslove) {
    let script = document.createElement('script');
    script.src = src;
    script.onload = reslove;
    document.body.appendChild(script);
}
loadScript('./1.js', () => {
    show();
});
loadScript('./2.js', () => {
    run();
});

由于加载js的顺序是不一定的，也就是说，谁加载完毕之后，谁就放入到任务队列中，并不适用代码执行顺序来放入到任务队列中。所有有时候会报错

# 所有我们只能等1.js加载完再去加载2.js
修改如下

loadScript('./1.js', () => {
        show();
        loadScript('./2.js', () => {
        run();
    });
});

这样的弊端就是需要大量的嵌套，如果有其他函数害依赖run函数那么就需要一直嵌套下去，嵌套关系越来越复杂，我们后面会讲到promise会解决这个问题。
```



## 4. ajax请求之任务队列

```js
这里我们暂时无法模拟，但是，ajax请求也是会放到任务队列中，也是需要等待主线程执行完毕，才放入主线程里去执行。
```



## 5. Promise之任务队列【微任务】

```js
// 我们需要使用new 关键字来创建 一个promise 
例如下面这样属于pending 【准备状态】
new Promise((resolve,reject) => {})

但是一个回调必须有成功 或者 失败状态

1. 成功状态 执行resolve()函数
new Promise((resolve,reject) => {
    resolve('成功了'); 
})
Promise {<resolved>: "成功了"} // 由pending 状态 变为 resolved 代表成功状态 

2. 失败状态 reject()函数
new Promise((resolve,reject) => {
    reject('失败了'); // 执行resolve()函数代表成功
})

Promise {<rejected>: "失败了"} // 由pending 状态 变为 rejected 代表失败状态


3. 当状态由pending状态 变为 成功或者失败的状态 的时候执行成功或失败的回调
第一种方法是使用.then()回调函数。.then(resolve,reject)接收两个参数第一个是resolve成功的回调函数，第二个是reject失败的回调函数
new Promise((resolve,reject) => {
    reject('失败了'); // 执行resolve()函数代表成功
})
    .then(() => {
    console.log('成功的回调函数')
},  () => {
    console.log('失败的回调函数')
})

4. 我们可以不写.then的第二个参数，直接改为.catch这样就是.then只处理成功的回到函数，.catch只处理失败的回调函数这样分工明确看着不累
new Promise((resolve,reject) => {
    reject('失败了'); // 执行resolve()函数代表成功
})
    .then(() => {
    console.log('成功的回调函数')
})
    .catch(() => {
    console.log('失败的回调函数')
})

也是当执行到Promise的时候放入到任务队列，任务队列分两种一种是微任务队列，一种是宏任务队列，Promise属于微任务队列，微任务会先执行，宏任务会后执行
```



## 6. 宏任务与微任务执行顺序

```js
# 先执行同步任务 在执行异步任务 异步任务分为宏任务和微任务，先执行微任务，在执行宏任务

1.在Promise构造函数中的代码是同步执行的
new Promise(() => {
    console.log(1);
})
.then(() => {
    console.log(3); // 注意这里是不会执行的 因为他必须要等到一个成功的通知 才会执行 这时候是没有通知的所以不会执行
})
console.log(2);

// 输出内容为 1 2

2.
new Promise(resolve => {
    console.log(1);
    resolve('成功了');
})
.then(res => {
    console.log(res); // 这时候我们得到了一个成功的通知我们会把这个任务【.then()这个任务】放到任务队列的微任务中
})
console.log(2);

// 输出内容为  1 2 '成功了'

3.
setTimeout(() => console.log('setTimeout'), 1000)
new Promise(resolve => {
    console.log(1);
    resolve('成功了');
})
.then(res => {
    console.log(res); // 这时候我们得到了一个成功的通知我们会把这个任务【.then()这个任务】放到任务队列的微任务中
})
console.log(2);

// 输出内容为  1 2 '成功了' 'setTimeout'


4. 
new Promise(resolve => {
    console.log(1);
    setTimeout(() => {
        console.log('setTimeout'); // 这两行代码顺序调换其实输出结果是一样的，没有影响
        resolve('成功了'); // 这两行代码顺序调换其实输出结果是一样的，没有影响
    }, 1000)
})
.then(res => {
    console.log(res);
})
console.log(2);

上面是先执行定时器的宏任务才发现微任务，此时的定时器宏任务已经拿到主线程去执行了，就算遇到微任务，会先放到微任务中，等待主线程执行完毕在去轮询任务队列。

// 输出内容为  1 2 'setTimeout' '成功了' 
```



## 7. Promise状态不可更改

```js
1.
new Promise((resolve,reject) => {
    resolve('成功了'); // 由pending变更为resolved状态
    reject('失败了'); // 再次改变状态是不生效的 不可以更改的
})
.then(res => {
    console.log(res);
})
.catch(err => {
    console.log(err);
})


2. resolve,reject传递promise

1. 成功的状态
const promise1 = new Promise((resolve,reject) => {
    resolve('成功了');
});
// 其实返回的成功的状态

2.失败的状态
const promise2 = new Promise((resolve,reject) => {
    reject('失败了');
});

3. 准备的状态
const promise3 = new Promise((resolve,reject) => {
    
});
new Promise((resolve,reject) => {
   // resolve(promise1); // 其实传递的是一个promise的状态
   // reject(promise2);  // 其实传递的是一个promise的状态
   // resolve(promise3);
    resolve(promise2); // 用成功的状态传递一个失败的状态 那么由传递的状态为主
})
.then(res => {
    console.log(res);
})
.catch(err => {
    console.log(err);
})
```



## 8. 了解Promise.then的基本语法

```js
1.
new Promise((resolve,reject) => {
    resolve('1');
})
    .then( res => console.log(res), err => {})

2. 不需要成功的回调传入一个null就行了
new Promise((resolve,reject) => {
    reject('err');
})
    .then(null, err => console.log(err));

3. 多个then 如果上个then返回状态为resolved 会接着执行下面的then 如果返回 rejected会执行catch
new Promise((resolve,reject) => {
    resolve('1')
})
    .then()
    .then(res => console.log(res));

4.
new Promise((resolve,reject) => {
    resolve('1')
})
    .then()
    .then(res => console.log(res))
    .then(res => console.log('111'))


5.Promise.then也是一个Promise
let p1 = new Promise((resolve,reject) => {
    resolve('1')
})
console.log(p1); // Promise {<resolved>: "1"} resloved状态
let p2 = p1.then()
console.log(p2); // Promise {<pending>} pending状态
先执行同步 在去任务队列轮询

6.
new Promise((resolve,reject) => {
    reject('1');
})
    .then(null, err => {
    console.log(err)
    return 2;
}) // 别看他是reject 但是执行完之后的状态还是resolved是成功的,所以还是会执行 下个then()方法
    .then(res => console.log(res));

如果then里面return 一个普通值 会传入下一个then里面，这时候状态会变为resolved，如果返回的是一个promise那么会传递这个promise的状态到下一个then/catch中，如果是pending状态则不会传递到，注意必须【return】一个promise才行，下一个then才是对这个return的promise状态进行处理，要不然不会对这个promise进行处理,后面的then就是对前面返回的promise状态进行处理

7. return 一个promise
new Promise((resolve,reject) => {
    resolve('1');
})
    .then(res => {
    return new Promise((resolve,reject) => {
        resolve('return promise')
    })
})
    .then(res => console.log(res));

// return promise

8. 不return一个promise
new Promise((resolve,reject) => {
    resolve('1');
})
    .then(res => {
    new Promise((resolve,reject) => {
        resolve('return promise')
    })
})
    .then(res => console.log(res));

// undefined


*9. // 模拟 我们需要一个接口返回来的数据 去请求另一个接口 
ajax()
    .then(res=>{
     return ajax2(res.userId);
})
    .then((res) => {
    console.log(res, '数据')
})
```



## 9. Promise.catch

```js
用来捕获失败状态的回调
1.
new Promise((resolve,reject) => {
    reject('失败了');
})
    .then(null,err => {
    console.log(err)
})


2.上面写法，then的第二个参数，可以简写下面这样
new Promise((resolve,reject) => {
    reject('失败了');
})
    .catch(err => {
    console.log(err)
})

3.多个catch
new Promise((resolve,reject) => {
    reject('失败了');
})
    .then(res => { console.log(res), err => console.log(err, 'then里面的回调'))
    .catch(err => {
    console.log(err);
})
    .then(() => console.log('catch执行完后执行'))

// 失败了 then里面的回调 catch执行完后执行
                  
会执行第一个catch 如果catch里面没有在抛出rejected的状态 那么状态会变为resolved状态
```



## 10. Promise.finally

```js
无论是成功状态还是失败状态都会执行，一般用于完成关闭loading加载
new Promise((resolve,reject) => {
    // reject('失败了');
    resolve('成功了');
})
    .then(res => {
    console.log(res)
})
    .catch(err => {
    console.log(err)
})
    .finally(() => {
    console.log('执行完毕,永远会执行');
})

```



## 11. Promise封装setTimeout定时器

```js
function timeout(delay = 1000) {
    return new Promise(resolve => {
        console.log(resolve)
        setTimeout(resolve,delay);
    })
}

timeout(2000).then(() => console.log(1));
```



## 12.  构建扁平化的setInterval

```js
function interval(delay = 1000, callback) {
    return new Promise((resolve,reject) => {
        let timerCode = setInterval(() => {
            callback(timerCode, resolve)
        },delay)
    })
}
interval(1000,(timerCode, resolve)=>{
    console.log('循环开始');
    // clearInterval(timerCode);
    resolve('111');
})
    .then((res) => {
    console.log(res);
    console.log('成功了');
})
```



## 13. Promise.resolve()缓存后台数据

```js
new Promise((resolve) => {
    resolve('成功的promise');
}); // 其实就是对这个的简写

Promise.resolve('成功的promise'); // Promise {<resolved>: "成功的promise"}

Promise.resolve('成功的promise').then(res => console.log(res)); // 成功的promise


function getTableData(name) {
    const cache = getTableData.cache || (getTableData.cache = new Map());
    
    if (cache.has(name)) {
        console.log("走缓存了");
        return Promise.resolve(cache.get(name));
     }
   
    return ajax().then( res => {
          cache.set(name, res);
          console.log("没走缓存");
          return res;
     })
    
    setInterval(() => {
        getTableData('a')
    }, 1000);
```



## 14. Promise.reject()

```js
以前的写法：
new Promise((resolve, reject) => {
    reject('失败了');
})
    .catch(err => console.log(err));

简写
Promise.reject('失败了').catch(err => console.log(err));
```



## 15. Promise.all批量获取数据

```js
所有的promise返回成功，才是成功的状态，有一个返回失败就是失败的状态，属于并行完成

1. 全部成功
let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.resolve('成功的promise2');
Promise.all([
    p1,
    p2
])
    .then(res => console.log(res)); // ["成功的promise1", "成功的promise2"]

2. 有一个失败的
let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
Promise.all([
    p1,
    p2,
    p3
])
    .then(res => console.log(res))
    .catch(err => console.log(err)) // 失败的promise1

3. 多个失败的 返回第一个失败的
let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
Promise.all([
    p1,
    p2,
    p3
])
    .then(res => console.log(res))
    .catch(err => console.log(err)) // 失败的promise1

```



## 16. Promise.allSettled()使用

```js
// 返回所有状态 不管成功 失败

let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
Promise.allSettled([
    p1,
    p2,
    p3
])
    .then(res => console.log(res, 'res'));

//  [
// {status: "fulfilled", value: "成功的promise1"},
// {status: "rejected", reason: "失败的promise1"}, 
// {status: "rejected", reason: "成功的promise2"}
// ]

# 成功的返回成功状态 和 请求成功的结果的值，失败的返回失败的原因和失败的值

永远返回是成功的状态也就是说走then

妙用：筛选出成功的 回调

let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
Promise.allSettled([
    p1,
    p2,
    p3
])
    .then(res => {
    return res.filter(item => item.status === 'fulfilled')
}).then(res => console.log(res, 'res'));
```



## 17. Promise.race后台请求超时处理

```js
批量获取多个Promise,只取返回最快的那个
race： 竞赛
#： 使用
let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
Promise.race([
    p1,
    p2,
    p3
])
    .then(res => console.log(res))
    .catch(err => console.log(err));


1.实际应用 如果所有请求都超过两秒 那么我们自定义一个请求超时的promise返回去
let p1 = Promise.resolve('成功的promise1');
let p2 = Promise.reject('失败的promise1');
let p3 = Promise.reject('成功的promise2');
let p4 = new Promise(resolve => {
    setTimeout(()=> {
        resolve('请求超时');
    }, 3000)
})
Promise.race([
    p1,
    p2,
    p3,
    p4
])
    .then(res => console.log(res))
    .catch(err => console.log(err));
```



## 18. async与await语法糖

```js
1.
async function run() {}
console.log(run()); 
// 我们打印执行run方法其实是个Promise  
// 状态为已完成【resolved】

async function run() {
    return 1
}
run().then(res => console.log(res));

2.
async function run() {
    let res = await new Promise((resolve) => {
        resolve(1);
    }) // await就是then的语法糖 then(res => resolve(1))
    console.log(res);
}
run();

3.
async function run() {
    let res = await this.$api.scheduleDispatch.getPath()
    console.log(res);
}
run();
```

## 19. async错误处理

```js
1.在外面处理
async function run() {
    let res = await new Promise((resolve,reject) => {
        // resolve(1);
        reject(3);
    })
    return res;
}
run()
    .then(res=> console.log(res, 'res'))
    .catch(error => console.log(error, 'err'));

2. reject模拟网络请求出错（在内部处理）
async function run() {
    try {
        let res = await new Promise((resolve,reject) => {
            reject(3);
            return res;
    })
    } catch(err) {
        console.log(err);
    }
}
run()

3. 系统内部自动抛错
async function run() {
    try {
        let res = await new Promise((resolve,reject) => {
            console.log(a); // 打印一个未定义的变量 
            return res;
    })
    } catch(err) {
        console.log(err.message);
    }
}
run()
```





