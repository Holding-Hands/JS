# 一. 走进javaScript黑洞

## 1. 注释与执行符

```js
单行注释
console.log(1); // 未注释，控制台打印1
// console.log(1); 注释之后控制台不会输出，就是让此行代码无效

多行注释
/*
* console.log(1);
* console.log(2);
**/

每段代码后要加【;】分号，要不然，代码压缩的时候，所有代码在一行显示，会报错，平时写代码要养成良好习惯，要加分号
```



## 2. 变量声明相关知识

```js
1. 使用var声明
// 必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字
var myName = 'zcy';
var myName = 'zcy';
var _myName = 'zcy';         
$name = 'zcy';

2. 错误的变量声明
var 6name;  // 开头不能用数字
var %sum; // 开头不能用除(_ $)外特殊符号,如(%  + /等)
var sum+num; // 开头中间不能使用除(_ $)外特殊符号，如(%  + /等)

注意: jqury使用的$符号，所以我们尽量不要用单独的$作为变量

3. 一次声明多个变量,使用逗号隔开最后一个用分号结束
var a = 1,
    b = 2,
    c = 3;

4. 多个变量赋值为相同的值

var a = b = c = d = 1;

5. 特殊的name属性
我们没有声明name属性，但直接打印name属性是有值的,name指的是窗口的名字，所以使用name属性要注意些
console.log(name); // ''
console.log(window.name); // 是一样的 ''
```



## 3. js解析过程(预解析)与变量提升

```js
当我们使用关键字进行声明的时候，会报错 如下图所示
var if = 1;
```

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/29f00ca9-cb6b-412a-85bb-43d3e301b673.png)



```js
// 我们来看这个例子，js执行顺序是从上往下执行，那么是不是先打印变量a，在报错呢，我们验证一下猜想
var a = 1;
console.log(a);
var if = 1;
```

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/29f00ca9-cb6b-412a-85bb-43d3e301b673.png)

```js
// 我们的验证时错误的，并没有打印变量a，直接报错，这是为什么呢?
// 原来是因为执行js代码前，解析器会分析我们的代码（也叫预解析），在这个分析过程中就执行了变量提升；

我们看个例子，我们先打印个没有声明过的变量
console.log(zbc); 
```

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/14ce74e2-be7d-4337-86f2-518f548fa918.png)

我们不难发现直接打印一个未声明的变量会报错

```js
那么我们看下面这个例子,大家是否觉得。还是会报错呢?
console.log(sm);
var sm = 'A';
```

![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/efc33aa0-e003-44cd-94f5-0cec3fd9877a.png)

```js
结果是没报错，打印变量sm为undefined，这是为什么呢？大家心里一定想js执行代码，不是从上往下执行么，为什么在打印语句，后面声明sm变量不会报错呢？

我们之前说过执行js代码前，解析器会分析我们的代码（也叫预解析）,在这个分析过程中（预解析）就执行了变量提升。
那么什么是变量提升?
console.log(sm); // undefined
var sm = 'A';
// 上面的声明变量的语句，原来做了两件事
1. var sm;
2. sm = 'A';


所以说执行js代码前，解析器会分析我们的代码，把第一步提到前面了，上面的代码就变为下面代码，这就是变量提升

var sm;
console.log(sm); // 如果一个变量只声明，未赋值那么值未undefined
sm = 'A';

```

## 4. let与const暂时性死区

```js
我们上面说到变量提升是不好的，一般推荐是，先声明在使用，当有变量提升之后是可以先用，后声明这样是不好的，所以我们引用let，const解决这种变量提升的问题，暂时性死区就是必须先声明在使用，在声明之前都是死区，使用这个变量会报错

// 我们使用let代替var声明试试
console.log(a);
let a = 1;
// 这时候会报错提示【a is not defined】与var不同，let没有变量提升，这样就做到了先声明在使用的原则


看下面几个例子
1.
function run (a = b, b = 1) {
    
} // 会报错, b没有声明，但是已经使用了，函数形参相当于使用let进行了声明
run();

2.
let a = 1;
function run () {
    console.log(a);
    let a = 1;
} 
// 会报错,如果函数内部有使用这个变量并且还发现了这个变量的声明语句，就不会沿着作用域向外查找变量这时候属于先使用后声明，所以会报错
run();
```



## 5. let，const，var共同点

```js
看个例子
1.
// var a = 1;
// let a = 1;
const a = 1;
function show() {
    console.log(a); // 1
}
show();
// 函数中可以访问外部全局的变量的，这是这三个的共同点

2.
var a = 1;
function show() {
    var a = 2;
    console.log(a); // 2
}
console.log(a); // 1
show();
其实不难理解，函数就相当于你的私有空间，外部（全局）不能访问，但你可以访问外部（全局，公共的）的变量；
```

