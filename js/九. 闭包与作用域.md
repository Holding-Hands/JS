# 九. 闭包与作用域

## 1. 环境与作用域

```js
好比一个城市就是一个环境，包括学校，公园，超市，但是如果人都没有了，这个环境也不被需要，也就没什么意义，可能会受到大自然，或者人工毁灭，总而言之环境不被需要就会被回收或者被破坏掉。
城市里面的环境是有作用范围的，公园，超市，都是服务周边人群的，可以叫作用域

let title = 'qs';
console.log(title);
// 当我们在全局环境定义一个变量，后面使用到就不会被回收

// 那么我们在全局环境定义一个变量，不用会不会回收呢？
let num = 1;
其实也不会，因为全局环境被控制台依赖，我们可以在控制台上使用，有人使用就不会被回收
# 事实证明在全局声明的变量即使不用也是不会回收的。除非关掉浏览器会回收


let a = 2;
function run () {
    console.log(a);
}
run(); // 在js中函数全局变量可以渗透到函数中，也就是说函数中可以用全局的变量，但是在php中是不行的，这是全局的差别
```



## 2. 函数环境与作用域原理

```js
function show () {
    let name = 'sm';
}
show();
// 当我们调用函数的时候，会创建一个环境（或者说在内存地址新开辟一块空间比如说叫show)，我们show的空间定义了一个变量name,在show的空间中又开辟一个地址,这个变量属于show函数，那么作用范围在show环境里面, 如果调用多次，每一次都会重新开辟新的空间，是不同的


function show () {
    let name = 'sm';
    function run () {
        let name = 'zcy';
    } // 在show函数中开辟的空间中又开辟了一个run函数的空间
    console.log(name) // 访问不到，会报错
}
show();

# 注意没调用就没开辟空间，如果函数作用域中的变量或函数未被引用，则调用完，函数开辟的空间(作用域)立即销毁，调用完如果函数作用域中的变量或函数未被引用，则用完函数作用域立即销毁，函数内部产生的数据，没有用到的话会被清除开辟的这块空间
```



## 3. 延伸函数环境生命周期

```js
1.
function sum () {
    let n = 1;
    function a() {
        n++;
        console.log(n);
    }
    a();
    return n
}
sum(); // 2
sum(); // 2
sum(); // 2
// 调用多次n不会累加,每次调用开辟一个新的内存地址，就相当于函数产生的内存数据没人用那么就会清除掉，就相当于公园一直有人去，就会一直有用，就不会被破坏掉，所以我们能不能把函数产生的内存数据让外面一直用呢，就不会清除掉函数的内存地址

2.
function sum () {
    let n = 1;
    let obj = {};
    return function a() {
        n++;
        obj = { n };
        console.log(obj, n);
    }
    a();
    return obj; // 返回一个自定义的引用类型
}
let c = sum; // 把返回的引用对象进行变量赋值
c(); // { n: 2 }
c(); // { n: 2 }
c(); // { n: 2 } 无论调用多少次，结果是不变的

3.
function sum () {
    let n = 1;
    return function a() {
        n++;
        console.log(n);
    }// 返回一个自定义的引用类型
}
let b = sum(); 
b(); // 2
b(); // 3
b(); // 4
// 相当于sum函数中产生的内存数据，a函数在外面用到了，所以就不会清除

4. // 看个例子
function sum () {
    let n = 1;
    return function a() {
        n++;
        console.log(n);
    }
}
let b = sum(); 
b(); // 2
b(); // 3
let d = sum(); // 切记每次调用函数产生一个新的内存空间
d(); // 2
d(); // 3

# 总结
1.如果不存在嵌套的函数，也没有其他引用指向这个绑定的对象，它就会被当做垃圾回收掉。
2.如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。
3.如果这些嵌套函数对象在外部函数中保存了下来(比如赋值给外部函数中的某个变量)，它们也会和所指向的变量绑定对象一样当做垃圾回收
4.但是如果这个函数定义了嵌套函数，并将它们作为返回值返回，或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套函数，它就不会被当做垃圾回收。并且它所指向的变量绑定对象也不会被当作垃圾回收。
```



## 4. 构造函数中的作用域的使用形态

```js

```

